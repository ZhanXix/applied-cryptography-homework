/* zhanxix */

#include <iostream>
#include <fstream>
#include <map>
#include <string>
using std::cout;
using std::endl;
using std::map;
using std::ofstream;
using std::string;

//测试用
int test_Compute_DDT(short* S, string Sname);
int test_Compute_LAT(short* S, string Sname);
//实际计算
int Compute_DDT(short(*S)[16], string Sname);
int Compute_LAT(short(*S)[16], string Sname);

int main()
{
	//test_S
	short testS[16] = { 14,4,13,1,
						2,15,11,8,
						3,10,6,12,
						5,9,0,7 };
	test_Compute_DDT(testS, "testS");
	test_Compute_LAT(testS, "testS");
				
	//ZUC-S0
	short S0[16][16] =
	{ {0x3E,0x72,0x5B,0x47,0xCA,0xE0,0x00,0x33,0x04,0xD1,0x54,0x98,0x09,0xB9,0x6D,0xCB}
		,{0x7B,0x1B,0xF9,0x32,0xAF,0x9D,0x6A,0xA5,0xB8,0x2D,0xFC,0x1D,0x08,0x53,0x03,0x90}
		,{0x4D,0x4E,0x84,0x99,0xE4,0xCE,0xD9,0x91,0xDD,0xB6,0x85,0x48,0x8B,0x29,0x6E,0xAC}
		,{0xCD,0xC1,0xF8,0x1E,0x73,0x43,0x69,0xC6,0xB5,0xBD,0xFD,0x39,0x63,0x20,0xD4,0x38}
		,{0x76,0x7D,0xB2,0xA7,0xCF,0xED,0x57,0xC5,0xF3,0x2C,0xBB,0x14,0x21,0x06,0x55,0x9B}
		,{0xE3,0xEF,0x5E,0x31,0x4F,0x7F,0x5A,0xA4,0x0D,0x82,0x51,0x49,0x5F,0xBA,0x58,0x1C}
		,{0x4A,0x16,0xD5,0x17,0xA8,0x92,0x24,0x1F,0x8C,0xFF,0xD8,0xAE,0x2E,0x01,0xD3,0xAD}
		,{0x3B,0x4B,0xDA,0x46,0xEB,0xC9,0xDE,0x9A,0x8F,0x87,0xD7,0x3A,0x80,0x6F,0x2F,0xC8}
		,{0xB1,0xB4,0x37,0xF7,0x0A,0x22,0x13,0x28,0x7C,0xCC,0x3C,0x89,0xC7,0xC3,0x96,0x56}
		,{0x07,0xBF,0x7E,0xF0,0x0B,0x2B,0x97,0x52,0x35,0x41,0x79,0x61,0xA6,0x4C,0x10,0xFE}
		,{0xBC,0x26,0x95,0x88,0x8A,0xB0,0xA3,0xFB,0xC0,0x18,0x94,0xF2,0xE1,0xE5,0xE9,0x5D}
		,{0xD0,0xDC,0x11,0x66,0x64,0x5C,0xEC,0x59,0x42,0x75,0x12,0xF5,0x74,0x9C,0xAA,0x23}
		,{0x0E,0x86,0xAB,0xBE,0x2A,0x02,0xE7,0x67,0xE6,0x44,0xA2,0x6C,0xC2,0x93,0x9F,0xF1}
		,{0xF6,0xFA,0x36,0xD2,0x50,0x68,0x9E,0x62,0x71,0x15,0x3D,0xD6,0x40,0xC4,0xE2,0x0F}
		,{0x8E,0x83,0x77,0x6B,0x25,0x05,0x3F,0x0C,0x30,0xEA,0x70,0xB7,0xA1,0xE8,0xA9,0x65}
		,{0x8D,0x27,0x1A,0xDB,0x81,0xB3,0xA0,0xF4,0x45,0x7A,0x19,0xDF,0xEE,0x78,0x34,0x60}
	};

	//ZUC-S1
	short S1[16][16] =
	{ {0x55,0xC2,0x63,0x71,0x3B,0xC8,0x47,0x86,0x9F,0x3C,0xDA,0x5B,0x29,0xAA,0xFD,0x77}
		,{0x8C,0xC5,0x94,0x0C,0xA6,0x1A,0x13,0x00,0xE3,0xA8,0x16,0x72,0x40,0xF9,0xF8,0x42}
		,{0x44,0x26,0x68,0x96,0x81,0xD9,0x45,0x3E,0x10,0x76,0xC6,0xA7,0x8B,0x39,0x43,0xE1}
		,{0x3A,0xB5,0x56,0x2A,0xC0,0x6D,0xB3,0x05,0x22,0x66,0xBF,0xDC,0x0B,0xFA,0x62,0x48}
		,{0xDD,0x20,0x11,0x06,0x36,0xC9,0xC1,0xCF,0xF6,0x27,0x52,0xBB,0x69,0xF5,0xD4,0x87}
		,{0x7F,0x84,0x4C,0xD2,0x9C,0x57,0xA4,0xBC,0x4F,0x9A,0xDF,0xFE,0xD6,0x8D,0x7A,0xEB}
		,{0x2B,0x53,0xD8,0x5C,0xA1,0x14,0x17,0xFB,0x23,0xD5,0x7D,0x30,0x67,0x73,0x08,0x09}
		,{0xEE,0xB7,0x70,0x3F,0x61,0xB2,0x19,0x8E,0x4E,0xE5,0x4B,0x93,0x8F,0x5D,0xDB,0xA9}
		,{0xAD,0xF1,0xAE,0x2E,0xCB,0x0D,0xFC,0xF4,0x2D,0x46,0x6E,0x1D,0x97,0xE8,0xD1,0xE9}
		,{0x4D,0x37,0xA5,0x75,0x5E,0x83,0x9E,0xAB,0x82,0x9D,0xB9,0x1C,0xE0,0xCD,0x49,0x89}
		,{0x01,0xB6,0xBD,0x58,0x24,0xA2,0x5F,0x38,0x78,0x99,0x15,0x90,0x50,0xB8,0x95,0xE4}
		,{0xD0,0x91,0xC7,0xCE,0xED,0x0F,0xB4,0x6F,0xA0,0xCC,0xF0,0x02,0x4A,0x79,0xC3,0xDE}
		,{0xA3,0xEF,0xEA,0x51,0xE6,0x6B,0x18,0xEC,0x1B,0x2C,0x80,0xF7,0x74,0xE7,0xFF,0x21}
		,{0x5A,0x6A,0x54,0x1E,0x41,0x31,0x92,0x35,0xC4,0x33,0x07,0x0A,0xBA,0x7E,0x0E,0x34}
		,{0x88,0xB1,0x98,0x7C,0xF3,0x3D,0x60,0x6C,0x7B,0xCA,0xD3,0x1F,0x32,0x65,0x04,0x28}
		,{0x64,0xBE,0x85,0x9B,0x2F,0x59,0x8A,0xD7,0xB0,0x25,0xAC,0xAF,0x12,0x03,0xE2,0xF2}
	};

	Compute_DDT(S0, "S0");
	Compute_DDT(S1, "S1");

	Compute_LAT(S0, "S0");
	Compute_LAT(S1, "S1");

	return 0;
}

int Compute_DDT(short(*S)[16], string Sname)//计算差分分布表
{
	map<short, short> DDT;

	short ix, x1, x2;	//x1和x2是两个输入值（8bit），ix是其差值
	short x10, x11, x20, x21;	//x10是x1的左4bit，x11是x1的右4bit
	short y1, y2;		//y1和y2是两个输入值，iy是其差值
	short iy;
	for (ix = 0x00; ix <= 0xFF; ++ix)
	{
		for (x1 = 0x00; x1 <= 0xFF; ++x1)
		{
			x10 = (x1 & 0xF0) >> 4;
			x11 = x1 & 0x0F;
			x2 = x1 ^ ix;
			x20 = (x2 & 0xF0) >> 4;
			x21 = x2 & 0x0F;
			y1 = S[x10][x11];
			y2 = S[x20][x21];
			iy = y1 ^ y2;
			DDT[ix * 256 + iy]++;
		}
	}

	ofstream ofs;
	ofs.open("DDT-" + Sname + ".txt");
	if (!ofs)
	{
		cout << "ofstream open file error!" << endl;
		return -1;
	}

	for (int i = 0; i < 256; ++i)	//输出差分分布表
	{
		for (int j = 0; j < 256; ++j)
		{
			//cout << DDT[i * 256 + j] << " ";
			ofs << DDT[i * 256 + j] << " ";
		}
		//cout << endl;
		ofs << endl;
	}

	return 0;
}

int Compute_LAT(short(*S)[16], string Sname)//计算线性近似表
{
	//map<short, short> LAT;

	short x, y;			//x和y表示输入值和输出值
	short x10, x01;	//x10是x1的左4bit，x01是x1的右4bit
	short i_flag, o_flag;//i_flag和o_flag表示输入系数和输出系数
	short i_flag_2, o_flag_2;
	short x_i, y_o;
	short x_result, y_result;//表示等式两边的结果
	short count;

	ofstream ofs;
	ofs.open("LAT-" + Sname + ".txt");
	if (!ofs)
	{
		cout << "ofstream open file error!" << endl;
		return -1;
	}

	for (i_flag = 0x00; i_flag <= 0xFF; ++i_flag)
	{
		for (o_flag = 0x00; o_flag <= 0xFF; ++o_flag)
		{
			count = 0;
			for (x = 0x00; x <= 0xFF; ++x)
			{
				x10 = (x & 0xF0) >> 4;
				x01 = x & 0x0F;
				y = S[x10][x01];	//从S盒查询出输出值
				x_i = x & i_flag;
				y_o = y & o_flag;

				short left1 = 0;
				i_flag_2 = i_flag;
				if (i_flag_2 != 0)
				{
					i_flag_2 = i_flag_2 >> 1;
					left1 = 1;
					while (i_flag_2 != 0)
					{
						i_flag_2 = i_flag_2 >> 1;
						left1 = left1 << 1;
					}
				}

				if (x_i & left1)
				{
					x_result = 1;
				}
				else
				{
					x_result = 0;
				}
				left1 = left1 >> 1;
				while (left1 != 0)
				{
					if (i_flag & left1)
					{
						if (x_i & left1)
						{
							x_result ^= 1;
						}
						else
						{
							x_result ^= 0;
						}
					}
					left1 = left1 >> 1;
				}

				o_flag_2 = o_flag;
				left1 = 0;
				if (o_flag_2 != 0)
				{
					o_flag_2 = o_flag_2 >> 1;
					left1 = 1;
					while (o_flag_2 != 0)
					{
						o_flag_2 = o_flag_2 >> 1;
						left1 = left1 << 1;
					}
				}

				if (y_o & left1)
				{
					y_result = 1;
				}
				else 
				{
					y_result = 0;
				}
				left1 = left1 >> 1;
				while (left1 != 0)
				{
					if (o_flag & left1)
					{
						if (y_o & left1)
						{
							y_result ^= 1;
						}
						else
						{
							y_result ^= 0;
						}
					}
					left1 = left1 >> 1;
				}

				if (x_result == y_result)
				{
					count++;
				}
			}
			count -= 128;
			//cout << count << " ";
			ofs << count << " ";
		}
		//cout << endl;
		ofs << endl;
	}

	return 0;
}

int test_Compute_DDT(short* S, string Sname)
{
	short DDT[16] = { 0 };

	short ix, x1, x2;	//x1和x2是两个输入值（4bit），ix是其差值
	short y1, y2;		//y1和y2是两个输入值，iy是其差值
	short iy;

	ofstream ofs;
	ofs.open("DDT-" + Sname + ".txt");
	if (!ofs)
	{
		cout << "ofstream open file error!" << endl;
		return -1;
	}

	for (ix = 0x0; ix <= 0xF; ++ix)
	{
		for (x1 = 0x0; x1 <= 0xF; ++x1)
		{
			x2 = x1 ^ ix;
			y1 = S[x1];
			y2 = S[x2];
			iy = y1 ^ y2;
			DDT[iy]++;
		}
		for (int i = 0; i < 16; ++i)
		{
			ofs << DDT[i] << " ";
		}
		ofs << endl;
		memset(DDT, 0, 16 * sizeof(short));
	}

	return 0;
}

int test_Compute_LAT(short* S, string Sname)
{
	short x, y;			//x和y表示输入值和输出值
	short x10, x01;	//x10是x1的前4bit，x01是x1的后4bit
	short i_flag, o_flag;//i_flag和o_flag表示输入系数和输出系数
	short i_flag_2, o_flag_2;
	short x_i, y_o;
	short x_result, y_result;//表示等式两边的结果
	short count;

	ofstream ofs;
	ofs.open("LAT-" + Sname + ".txt");
	if (!ofs)
	{
		cout << "ofstream open file error!" << endl;
		return -1;
	}

	for (i_flag = 0x0; i_flag <= 0xF; ++i_flag)
	{
		for (o_flag = 0x0; o_flag <= 0xF; ++o_flag)
		{
			count = 0;
			for (x = 0x0; x <= 0xF; ++x)
			{
				y = S[x];	//从S盒查询出输出值
				x_i = x & i_flag;
				y_o = y & o_flag;

				short left1 = 0;
				i_flag_2 = i_flag;
				if (i_flag_2 != 0)
				{
					i_flag_2 = i_flag_2 >> 1;
					left1 = 1;
					while (i_flag_2 != 0)
					{
						i_flag_2 = i_flag_2 >> 1;
						left1 = left1 << 1;
					}
				}

				if (x_i & left1)
				{
					x_result = 1;
				}
				else
				{
					x_result = 0;
				}
				left1 = left1 >> 1;
				while (left1 != 0)
				{
					if (i_flag & left1)
					{
						if (x_i & left1)
						{
							x_result ^= 1;
						}
						else
						{
							x_result ^= 0;
						}
					}
					left1 = left1 >> 1;
				}

				o_flag_2 = o_flag;
				left1 = 0;
				if (o_flag_2 != 0)
				{
					o_flag_2 = o_flag_2 >> 1;
					left1 = 1;
					while (o_flag_2 != 0)
					{
						o_flag_2 = o_flag_2 >> 1;
						left1 = left1 << 1;
					}
				}

				if (y_o & left1)
				{
					y_result = 1;
				}
				else
				{
					y_result = 0;
				}
				left1 = left1 >> 1;
				while (left1 != 0)
				{
					if (o_flag & left1)
					{
						if (y_o & left1)
						{
							y_result ^= 1;
						}
						else
						{
							y_result ^= 0;
						}
					}
					left1 = left1 >> 1;
				}

				if (x_result == y_result)
				{
					count++;
				}
			}
			count -= 8;
			//cout << count << " ";
			ofs << count << " ";
		}
		//cout << endl;
		ofs << endl;
	}

	return 0;
}